<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Org Chart JSON Viewer</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12);
      --text:#eef2ff;
      --muted:#b7c4ff;
      --accent:#66e3ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    body{ margin:0; background:var(--bg); color:var(--text); }
    header{ padding:14px 16px; border-bottom:1px solid var(--stroke); display:flex; gap:12px; flex-wrap:wrap; align-items:baseline; }
    header h1{ margin:0; font-size:16px; }
    header .sub{ color:var(--muted); font-size:13px; }
    .wrap{ display:grid; grid-template-columns: 380px 1fr; gap:12px; padding:12px; box-sizing:border-box; }
    @media (max-width: 980px){ .wrap{ grid-template-columns:1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:12px;
    }
    h2{ margin:0 0 10px; font-size:13px; color:var(--accent); }

    input[type="file"], select{
      width:100%;
      box-sizing:border-box;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--text);
      padding:10px;
      font-size:12px;
      outline:none;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .row > *{ flex:1; min-width: 160px; }
    button{
      cursor:pointer;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--text);
      padding:8px 10px;
      font-size:12px;
      flex:0 0 auto;
      min-width: 120px;
    }
    button.primary{
      border-color: rgba(102,227,255,.6);
      background: rgba(102,227,255,.12);
    }
    label{ color:var(--muted); font-size:12px; display:flex; gap:8px; align-items:center; user-select:none; }
    .hint{ color:var(--muted); font-size:12px; line-height:1.35; }

    .viewport{
      background: rgba(0,0,0,.14);
      border:1px solid var(--stroke);
      border-radius:14px;
      overflow:auto;
      height: 76vh;
      min-height: 520px;
    }
    svg{ display:block; width: 100%; height: 100%; min-width: 980px; min-height: 620px; }

    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      font-size:11px;
      color:var(--muted);
      margin-left:8px;
      white-space:nowrap;
    }

    .err{
      border:1px solid rgba(255,109,141,.45);
      background: rgba(255,109,141,.10);
      padding:10px;
      border-radius:12px;
      color: #ffd1da;
      font-size:12px;
      line-height:1.35;
      white-space: pre-wrap;
    }

    /* SVG styling */
    .nodeBox{ fill: rgba(0,0,0,.20); stroke: rgba(255,255,255,.16); stroke-width: 1.5; }
    .nodeTitle{ fill: rgba(238,242,255,.96); font-weight: 900; font-size: 13px; }
    .nodeMeta{ fill: rgba(183,196,255,.92); font-size: 11px; }
    .edge{ stroke: rgba(102,227,255,.65); stroke-width: 2.2; fill:none; }
    .edge.dotted{ stroke-dasharray: 6 6; }
    .edge.other{ stroke: rgba(178,139,255,.55); stroke-width: 1.8; }
    .edge.other.dotted{ stroke-dasharray: 5 6; }
  </style>
</head>
<body>
<header>
  <h1>Org Chart JSON Viewer</h1>
  <div class="sub">Upload your JSON → renders a top-down org chart using <span class="pill">reportsTo</span> as the hierarchy.</div>
</header>

<div class="wrap">
  <section class="card">
    <h2>Upload & view options</h2>

    <input id="fileInput" type="file" accept=".json,application/json"/>

    <div class="row">
      <div>
        <div class="hint" id="metaLine">No file loaded.</div>
      </div>
      <button class="primary" id="renderBtn" disabled>Render</button>
    </div>

    <div class="row">
      <div>
        <label>
          <input id="showOtherRels" type="checkbox" checked />
          Show non-reports relationships (purple)
        </label>
      </div>
      <div>
        <label>
          <input id="showIds" type="checkbox" />
          Show node IDs in label
        </label>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="rootSelect">Root node</label>
        <select id="rootSelect" disabled></select>
      </div>
      <div>
        <label for="dirSelect">Direction</label>
        <select id="dirSelect">
          <option value="top-down" selected>Top-down</option>
          <option value="left-right">Left-right</option>
        </select>
      </div>
    </div>

    <div style="margin-top:10px" id="errorBox"></div>

    <div class="hint" style="margin-top:10px;">
      <b>Notes:</b><br/>
      • Hierarchy uses <span class="pill">reportsTo</span> relationships: <span class="pill">from</span> reports to <span class="pill">to</span>.<br/>
      • Layout is a simple layered tree. Cycles or missing nodes are reported.<br/>
      • If the JSON contains <span class="pill">views[].rootNodeId</span>, it will be offered as the default root.
    </div>
  </section>

  <section class="card">
    <h2>Graphical representation</h2>
    <div class="viewport">
      <svg id="svg" viewBox="0 0 1400 900" preserveAspectRatio="xMidYMid meet" aria-label="Org chart diagram">
        <defs>
          <marker id="arrowCyan" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <path d="M0,0 L10,3 L0,6 Z" fill="rgba(102,227,255,.85)"></path>
          </marker>
          <marker id="arrowPurple" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
            <path d="M0,0 L10,3 L0,6 Z" fill="rgba(178,139,255,.65)"></path>
          </marker>
        </defs>
        <g id="gEdges"></g>
        <g id="gNodes"></g>
      </svg>
    </div>
  </section>
</div>

<script>
  const $ = (id) => document.getElementById(id);

  // -----------------------------
  // Parsing + validation
  // -----------------------------
  function safeJsonParse(text){
    try { return { ok:true, value: JSON.parse(text) }; }
    catch(e){ return { ok:false, error: String(e?.message || e) }; }
  }

  function getChartOrThrow(data){
    if (!data || typeof data !== "object") throw new Error("JSON must be an object.");
    if (!data.orgChart || typeof data.orgChart !== "object") throw new Error("Missing orgChart object.");
    const chart = data.orgChart;
    if (!Array.isArray(chart.nodes)) throw new Error("orgChart.nodes must be an array.");
    if (!Array.isArray(chart.relationships)) throw new Error("orgChart.relationships must be an array.");
    return chart;
  }

  function nodeLabel(node, showIds){
    const t = node.type;
    let main = node.displayName || node.title || node.name || node.id;
    if (t === "role" && node.title) main = node.title;
    if (t === "person" && node.displayName) main = node.displayName;
    if (t === "orgUnit" && node.name) main = node.name;
    if (t === "position" && node.name) main = node.name;

    const metaBits = [];
    metaBits.push(t || "node");
    if (node.status) metaBits.push(node.status);
    const meta = metaBits.join(" · ");

    if (showIds) main = `${main} (${node.id})`;
    return { main, meta };
  }

  // -----------------------------
  // Build hierarchy from reportsTo
  // reportsTo: from reports to to
  // So manager = to, subordinate = from
  // Edge direction for drawing: manager -> subordinate
  // -----------------------------
  function buildGraph(chart){
    const nodesById = new Map();
    for (const n of chart.nodes){
      if (!n?.id) continue;
      nodesById.set(n.id, n);
    }

    const reportsEdges = [];
    const otherEdges = [];
    for (const r of chart.relationships){
      if (!r || !r.type || !r.from || !r.to) continue;
      if (r.type === "reportsTo") reportsEdges.push(r);
      else otherEdges.push(r);
    }

    // adjacency: manager -> [subordinates]
    const children = new Map();
    const parent = new Map(); // subordinate -> manager (first one wins; org charts usually 1)
    for (const rel of reportsEdges){
      const sub = rel.from;
      const mgr = rel.to;
      if (!nodesById.has(sub) || !nodesById.has(mgr)) continue;

      if (!children.has(mgr)) children.set(mgr, []);
      children.get(mgr).push(sub);

      // only set if not already set (keep the primary line)
      if (!parent.has(sub)) parent.set(sub, mgr);
    }

    return { nodesById, reportsEdges, otherEdges, children, parent };
  }

  function pickDefaultRoot(chart, graph){
    // Prefer view root if present
    const viewRoot = chart.views?.[0]?.rootNodeId;
    if (viewRoot && graph.nodesById.has(viewRoot)) return viewRoot;

    // Otherwise: any node that is a manager (has children) and is not a subordinate
    const candidates = [];
    for (const [mgr, kids] of graph.children.entries()){
      if (!graph.parent.has(mgr)) candidates.push(mgr);
    }
    if (candidates.length) return candidates[0];

    // Otherwise: fall back to any node
    return chart.nodes?.[0]?.id || null;
  }

  // -----------------------------
  // Tree layout (simple layered)
  // -----------------------------
  function layoutTree(rootId, graph){
    const { children } = graph;

    // Detect cycles (DFS)
    const visiting = new Set();
    const visited = new Set();
    const cycleErrors = [];

    function dfsCycle(id){
      if (visiting.has(id)) { cycleErrors.push(`Cycle detected at ${id}`); return; }
      if (visited.has(id)) return;
      visiting.add(id);
      visited.add(id);
      const kids = children.get(id) || [];
      for (const k of kids) dfsCycle(k);
      visiting.delete(id);
    }
    dfsCycle(rootId);

    // Build levels via BFS from root
    const levels = [];
    const depth = new Map();
    const q = [rootId];
    depth.set(rootId, 0);

    while (q.length){
      const id = q.shift();
      const d = depth.get(id) || 0;
      if (!levels[d]) levels[d] = [];
      levels[d].push(id);

      const kids = children.get(id) || [];
      for (const k of kids){
        if (!depth.has(k)){
          depth.set(k, d+1);
          q.push(k);
        }
      }
    }

    // Postorder to compute subtree widths (for spacing)
    function subtreeSize(id){
      const kids = children.get(id) || [];
      if (!kids.length) return 1;
      return kids.reduce((a,k)=>a+subtreeSize(k),0);
    }

    // Assign x positions by walking subtrees left-to-right
    const x = new Map();
    const y = new Map();
    let cursor = 0;
    const NODE_W = 240;
    const NODE_H = 70;
    const H_GAP = 30;
    const V_GAP = 70;

    function assign(id, d){
      const kids = children.get(id) || [];
      if (!kids.length){
        x.set(id, cursor);
        y.set(id, d);
        cursor += 1;
        return;
      }
      for (const k of kids) assign(k, d+1);
      // center over children
      const first = kids[0], last = kids[kids.length-1];
      const cx = (x.get(first) + x.get(last)) / 2;
      x.set(id, cx);
      y.set(id, d);
    }
    assign(rootId, 0);

    // Convert grid coords to pixel coords
    const pos = new Map();
    let maxX = 0, maxY = 0;
    for (const [id, gx] of x.entries()){
      const px = gx * (NODE_W + H_GAP);
      const py = (y.get(id) || 0) * (NODE_H + V_GAP);
      pos.set(id, { x: px, y: py });
      maxX = Math.max(maxX, px);
      maxY = Math.max(maxY, py);
    }

    const width = maxX + NODE_W + 120;
    const height = maxY + NODE_H + 140;

    return { pos, NODE_W, NODE_H, width, height, cycleErrors };
  }

  // -----------------------------
  // Render SVG
  // -----------------------------
  function clearSvg(){
    $("gEdges").innerHTML = "";
    $("gNodes").innerHTML = "";
  }

  function mk(tag, attrs, parent){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (const [k,v] of Object.entries(attrs || {})) el.setAttribute(k, v);
    (parent || $("gNodes")).appendChild(el);
    return el;
  }

  function render(chart, graph, rootId, direction, showOther, showIds){
    clearSvg();

    const layout = layoutTree(rootId, graph);
    const { pos, NODE_W, NODE_H } = layout;

    // Update viewBox based on direction
    const W = layout.width;
    const H = layout.height;
    const svg = $("svg");
    svg.setAttribute("viewBox", `0 0 ${Math.max(900,W)} ${Math.max(600,H)}`);

    // Convenience mapping for direction
    function mapXY(p){
      if (direction === "left-right"){
        // swap axes (top-down → left-right)
        return { x: p.y, y: p.x };
      }
      return p;
    }

    // Draw reportsTo edges (manager -> subordinate)
    for (const rel of graph.reportsEdges){
      const sub = rel.from;
      const mgr = rel.to;
      if (!pos.has(sub) || !pos.has(mgr)) continue;

      const a = mapXY(pos.get(mgr));
      const b = mapXY(pos.get(sub));

      const x1 = a.x + NODE_W/2, y1 = a.y + NODE_H;
      const x2 = b.x + NODE_W/2, y2 = b.y;

      const midY = (y1 + y2) / 2;
      const d = `M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}`;
      const lineType = rel.attributes?.lineType === "dotted" ? "dotted" : "";
      const path = mk("path", {
        d,
        class: `edge ${lineType}`,
        "marker-end": "url(#arrowCyan)"
      }, $("gEdges"));
    }

    // Draw other edges (optional)
    if (showOther){
      for (const rel of graph.otherEdges){
        const from = rel.from, to = rel.to;
        if (!pos.has(from) || !pos.has(to)) continue;

        const a = mapXY(pos.get(from));
        const b = mapXY(pos.get(to));

        // simple straight-ish connector
        const x1 = a.x + NODE_W, y1 = a.y + NODE_H/2;
        const x2 = b.x,         y2 = b.y + NODE_H/2;

        const dx = Math.max(40, Math.abs(x2-x1)/2);
        const d = `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;

        const dotted = rel.attributes?.lineType === "dotted" ? "dotted" : "";
        mk("path", {
          d,
          class: `edge other ${dotted}`,
          "marker-end": "url(#arrowPurple)"
        }, $("gEdges"));
      }
    }

    // Draw nodes
    for (const [id, p0] of pos.entries()){
      const node = graph.nodesById.get(id);
      if (!node) continue;

      const p = mapXY(p0);
      const { main, meta } = nodeLabel(node, showIds);

      mk("rect", { x:p.x, y:p.y, width:NODE_W, height:NODE_H, rx:14, ry:14, class:"nodeBox" }, $("gNodes"));

      mk("text", { x:p.x+12, y:p.y+24, class:"nodeTitle" }, $("gNodes")).textContent = main;
      mk("text", { x:p.x+12, y:p.y+46, class:"nodeMeta" }, $("gNodes")).textContent = meta;
    }

    return layout;
  }

  // -----------------------------
  // UI wiring
  // -----------------------------
  let loaded = null; // { chart, graph }

  function setError(msg){
    const box = $("errorBox");
    box.innerHTML = msg ? `<div class="err">${escapeHtml(msg)}</div>` : "";
  }
  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
  }

  function populateRootSelect(chart, graph){
    const sel = $("rootSelect");
    sel.innerHTML = "";
    const opts = [];

    for (const n of chart.nodes){
      if (!n?.id) continue;
      opts.push(n.id);
    }
    opts.sort((a,b)=>a.localeCompare(b));

    for (const id of opts){
      const n = graph.nodesById.get(id);
      const label = n ? (n.displayName || n.title || n.name || n.id) : id;
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = `${label} — ${id}`;
      sel.appendChild(opt);
    }

    const defRoot = pickDefaultRoot(chart, graph);
    if (defRoot) sel.value = defRoot;
    sel.disabled = false;
  }

  function updateMetaLine(chart){
    const m = chart.meta || {};
    const name = m.name || "Org chart";
    const asOf = m.asOfDate ? `as of ${m.asOfDate}` : "";
    const ver = m.version ? `v${m.version}` : "";
    $("metaLine").textContent = `${name} ${ver} ${asOf}`.trim();
  }

  $("fileInput").addEventListener("change", async (e) => {
    setError("");
    $("renderBtn").disabled = true;
    $("rootSelect").disabled = true;
    loaded = null;

    const file = e.target.files?.[0];
    if (!file) return;

    const text = await file.text();
    const parsed = safeJsonParse(text);
    if (!parsed.ok){
      setError(`Invalid JSON:\n${parsed.error}`);
      return;
    }

    try{
      const chart = getChartOrThrow(parsed.value);
      const graph = buildGraph(chart);

      loaded = { chart, graph };
      updateMetaLine(chart);
      populateRootSelect(chart, graph);
      $("renderBtn").disabled = false;

      // auto-render once
      doRender();
    } catch(err){
      setError(String(err?.message || err));
    }
  });

  function doRender(){
    if (!loaded) return;
    setError("");

    const { chart, graph } = loaded;
    const rootId = $("rootSelect").value || pickDefaultRoot(chart, graph);
    if (!rootId){
      setError("Could not determine a root node.");
      return;
    }
    if (!graph.nodesById.has(rootId)){
      setError(`Root node not found in nodes: ${rootId}`);
      return;
    }

    const direction = $("dirSelect").value;
    const showOther = $("showOtherRels").checked;
    const showIds = $("showIds").checked;

    const layout = render(chart, graph, rootId, direction, showOther, showIds);

    const warnings = [];
    if (layout.cycleErrors.length){
      warnings.push(layout.cycleErrors.join("\n"));
    }

    // Missing relationships endpoints warning
    const allRel = [...graph.reportsEdges, ...graph.otherEdges];
    const missing = allRel
      .filter(r => r?.from && r?.to)
      .filter(r => !graph.nodesById.has(r.from) || !graph.nodesById.has(r.to))
      .slice(0, 20);
    if (missing.length){
      warnings.push(
        `Some relationships refer to missing nodes (showing first ${missing.length}):\n` +
        missing.map(r => `- ${r.id || "(no id)"}: ${r.type} ${r.from} -> ${r.to}`).join("\n")
      );
    }

    setError(warnings.length ? warnings.join("\n\n") : "");
  }

  $("renderBtn").addEventListener("click", doRender);
  $("rootSelect").addEventListener("change", doRender);
  $("dirSelect").addEventListener("change", doRender);
  $("showOtherRels").addEventListener("change", doRender);
  $("showIds").addEventListener("change", doRender);
</script>
</body>
</html>
