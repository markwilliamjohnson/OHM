<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Org Chart (Scrollable + Zoom/Pan)</title>
  <style>
    :root{
      --bg: #f7f8fb;
      --panel: #ffffff;
      --text: #0f172a;
      --muted:#64748b;
      --border:#e2e8f0;
      --shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      --accent:#2563eb;
      --accent2:#0ea5e9;

      --node-bg:#ffffff;
      --node-border:#cbd5e1;
      --node-shadow: 0 8px 18px rgba(15, 23, 42, 0.10);
      --node-text:#0f172a;
      --node-sub:#475569;

      --edge:#94a3b8;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --node-font-size: 13px; /* uniform across all nodes */
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: var(--font);
      color:var(--text);
      background:var(--bg);
      height:100vh;
      overflow:hidden; /* app controls scroll inside canvas */
    }

    .app{
      display:grid;
      grid-template-rows: auto 1fr;
      height:100vh;
    }

    header{
      background:var(--panel);
      border-bottom: 1px solid var(--border);
      box-shadow: 0 4px 16px rgba(15,23,42,.04);
      padding:10px 12px;
      display:flex;
      align-items:center;
      gap:10px;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      margin-right:10px;
      min-width: 180px;
    }
    .title strong{font-size:14px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}

    .controls{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    .btn{
      border:1px solid var(--border);
      background: #fff;
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      cursor:pointer;
      box-shadow: 0 2px 10px rgba(15,23,42,.04);
      transition: transform .05s ease, border-color .15s ease, box-shadow .15s ease;
      user-select:none;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{
      border-color:#c7d2fe;
      box-shadow: 0 6px 16px rgba(15,23,42,.08);
    }
    .btn:active{ transform: translateY(1px); }

    .btn.primary{
      border-color: #bfdbfe;
      background: linear-gradient(180deg, #ffffff, #f0f7ff);
    }

    .search{
      display:flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      background:#fff;
      border-radius:12px;
      padding:8px 10px;
      box-shadow: 0 2px 10px rgba(15,23,42,.04);
    }
    .search input{
      border:none;
      outline:none;
      font-size:12px;
      width:220px;
      background:transparent;
      color:var(--text);
    }
    .search .hint{ color: var(--muted); font-size:12px; }

    .status{
      margin-left:auto;
      color:var(--muted);
      font-size:12px;
      display:flex;
      gap:12px;
      align-items:center;
      white-space:nowrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      border:1px solid var(--border);
      border-bottom-width:2px;
      background:#fff;
      padding:2px 6px;
      border-radius:8px;
      color:var(--muted);
    }

    /* Scrollable stage (both directions) */
    .viewport{
      position:relative;
      overflow:auto; /* <-- enables left-right and up-down scrolling */
      background: radial-gradient(circle at 1px 1px, rgba(148,163,184,.25) 1px, transparent 0) 0 0/18px 18px,
                  linear-gradient(#ffffff, #ffffff);
    }

    /* Big content area to allow scrolling */
    .stage{
      position:relative;
      width: 4200px;
      height: 2600px;
      padding: 40px;
    }

    /* Zoom container */
    .zoomLayer{
      position:absolute;
      inset:0;
      transform-origin: 0 0;
      /* transform set via JS */
    }

    /* Edges behind nodes */
    svg.edges{
      position:absolute;
      inset:0;
      overflow:visible;
      pointer-events:none;
    }
    .edge{
      stroke: var(--edge);
      stroke-width: 2;
      fill: none;
      opacity: .85;
    }

    /* Nodes as lozenges */
    .node{
      position:absolute;
      min-width: 180px;
      max-width: 220px;
      padding: 10px 12px;
      background: var(--node-bg);
      border: 1px solid var(--node-border);
      border-radius: 999px;          /* lozenge */
      box-shadow: var(--node-shadow);
      font-size: var(--node-font-size); /* uniform */
      line-height: 1.2;
      color: var(--node-text);
      cursor: pointer;
      user-select:none;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .node .name{
      font-weight: 650;
      letter-spacing: .2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .node .role{
      color: var(--node-sub);
      font-weight: 520;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .node:focus{ outline: 3px solid rgba(37,99,235,.25); outline-offset:2px; }
    .node.selected{
      border-color: #93c5fd;
      box-shadow: 0 14px 28px rgba(37,99,235,.18);
    }

    /* Tiny tooltip */
    .toast{
      position:absolute;
      right:16px;
      bottom:16px;
      background: rgba(255,255,255,.95);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      color:var(--muted);
      font-size:12px;
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">
      <strong>Org Chart</strong>
      <span>Scroll + Pan + Zoom (light theme)</span>
    </div>

    <div class="controls">
      <button class="btn primary" id="fitBtn">Fit</button>
      <button class="btn" id="centerBtn">Center</button>
      <button class="btn" id="zoomInBtn">Zoom +</button>
      <button class="btn" id="zoomOutBtn">Zoom −</button>
      <button class="btn" id="resetBtn">Reset</button>

      <div class="search">
        <span class="hint">Search</span>
        <input id="searchInput" placeholder="e.g. CFO, Alex, Marketing…" />
        <button class="btn" id="searchBtn">Go</button>
      </div>
    </div>

    <div class="status">
      <span>Pan: <span class="kbd">drag</span></span>
      <span>Zoom: <span class="kbd">wheel</span></span>
      <span>Keys: <span class="kbd">←↑→↓</span></span>
    </div>
  </header>

  <div class="viewport" id="viewport" tabindex="0" aria-label="Org chart viewport">
    <div class="stage" id="stage">
      <div class="zoomLayer" id="zoomLayer">
        <svg class="edges" id="edges"></svg>
        <div id="nodes"></div>
      </div>
    </div>

    <div class="toast">
      Tip: use <b>Fit</b> after loading data, then search a name/role to jump.
    </div>
  </div>
</div>

<script>
  // Example data (replace with your JSON)
  const data = {
    nodes: [
      { id:"ceo", name:"Alex Morgan", role:"CEO" },
      { id:"cfo", name:"Sam Patel", role:"CFO" },
      { id:"cto", name:"Jordan Lee", role:"CTO" },
      { id:"coo", name:"Priya Singh", role:"COO" },
      { id:"hr",  name:"Taylor Kim", role:"Head of HR" },
      { id:"eng1",name:"Morgan Chen", role:"Engineering Manager" },
      { id:"eng2",name:"Casey Jones", role:"Engineering Manager" },
      { id:"fin1",name:"Ava Brown", role:"Finance Manager" },
      { id:"ops1",name:"Noah Wilson", role:"Operations Manager" },
      { id:"mkt1",name:"Riley Garcia", role:"Marketing Lead" }
    ],
    edges: [
      ["ceo","cfo"], ["ceo","cto"], ["ceo","coo"], ["coo","hr"], ["cto","eng1"], ["cto","eng2"],
      ["cfo","fin1"], ["coo","ops1"], ["ceo","mkt1"]
    ]
  };

  // Layout config
  const NODE_W = 210;      // approximate max width for lozenges
  const NODE_H = 56;       // fixed-ish height
  const H_GAP  = 70;
  const V_GAP  = 110;
  const ORIGIN = { x: 260, y: 120 };

  const viewport  = document.getElementById("viewport");
  const zoomLayer = document.getElementById("zoomLayer");
  const nodesHost = document.getElementById("nodes");
  const edgesSvg  = document.getElementById("edges");

  const fitBtn    = document.getElementById("fitBtn");
  const centerBtn = document.getElementById("centerBtn");
  const zoomInBtn = document.getElementById("zoomInBtn");
  const zoomOutBtn= document.getElementById("zoomOutBtn");
  const resetBtn  = document.getElementById("resetBtn");
  const searchInput = document.getElementById("searchInput");
  const searchBtn = document.getElementById("searchBtn");

  let scale = 1;
  let selectedId = null;

  // Build parent -> children map
  function buildTree(edges){
    const children = new Map();
    const parents  = new Map();
    for (const [p,c] of edges){
      if(!children.has(p)) children.set(p, []);
      children.get(p).push(c);
      parents.set(c, p);
    }
    // root = a node that is never a child
    const childSet = new Set(edges.map(e => e[1]));
    const root = data.nodes.find(n => !childSet.has(n.id))?.id ?? data.nodes[0]?.id;
    return { root, children, parents };
  }

  // Simple tidy-ish tree layout (level-order with sibling spacing)
  function layout(){
    const { root, children } = buildTree(data.edges);

    const levels = [];
    const q = [{ id: root, depth: 0 }];
    const seen = new Set();

    while(q.length){
      const { id, depth } = q.shift();
      if(seen.has(id)) continue;
      seen.add(id);
      if(!levels[depth]) levels[depth] = [];
      levels[depth].push(id);
      const kids = children.get(id) || [];
      for(const k of kids) q.push({ id: k, depth: depth + 1 });
    }

    // Assign x positions within each level
    const pos = new Map();
    for(let depth=0; depth<levels.length; depth++){
      const ids = levels[depth];
      // center the level around ORIGIN.x
      const totalW = ids.length * NODE_W + (ids.length - 1) * H_GAP;
      let x = ORIGIN.x - totalW / 2;
      const y = ORIGIN.y + depth * (NODE_H + V_GAP);
      for(const id of ids){
        pos.set(id, { x, y });
        x += NODE_W + H_GAP;
      }
    }
    return pos;
  }

  function render(){
    nodesHost.innerHTML = "";
    edgesSvg.innerHTML = "";

    const pos = layout();

    // Nodes
    for(const n of data.nodes){
      const p = pos.get(n.id) || { x: ORIGIN.x, y: ORIGIN.y };
      const el = document.createElement("div");
      el.className = "node";
      el.style.left = p.x + "px";
      el.style.top  = p.y + "px";
      el.tabIndex = 0;
      el.dataset.id = n.id;

      el.innerHTML = `
        <div class="name" title="${escapeHtml(n.name)}">${escapeHtml(n.name)}</div>
        <div class="role" title="${escapeHtml(n.role)}">${escapeHtml(n.role)}</div>
      `;

      el.addEventListener("click", () => selectNode(n.id, true));
      el.addEventListener("keydown", (e) => {
        if(e.key === "Enter" || e.key === " ") selectNode(n.id, true);
      });

      nodesHost.appendChild(el);
    }

    // Edges (draw center-bottom of parent to center-top of child)
    const svgW = 5000, svgH = 3200; // big enough for stage
    edgesSvg.setAttribute("width", svgW);
    edgesSvg.setAttribute("height", svgH);

    const nodeCenter = (id) => {
      const p = pos.get(id);
      if(!p) return null;
      return {
        x: p.x + NODE_W/2,
        yTop: p.y,
        yBottom: p.y + NODE_H
      };
    };

    for(const [pId, cId] of data.edges){
      const p = nodeCenter(pId);
      const c = nodeCenter(cId);
      if(!p || !c) continue;

      const x1 = p.x, y1 = p.yBottom;
      const x2 = c.x, y2 = c.yTop;

      const midY = y1 + (y2 - y1) * 0.55;
      const d = `M ${x1} ${y1} C ${x1} ${midY}, ${x2} ${midY}, ${x2} ${y2}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("class", "edge");
      edgesSvg.appendChild(path);
    }

    // Default select root
    const root = buildTree(data.edges).root;
    selectNode(root, false);
  }

  function setScale(next){
    scale = Math.max(0.35, Math.min(2.2, next));
    zoomLayer.style.transform = `scale(${scale})`;
  }

  function selectNode(id, scrollIntoView){
    selectedId = id;
    document.querySelectorAll(".node").forEach(n => {
      n.classList.toggle("selected", n.dataset.id === id);
    });
    if(scrollIntoView) centerOnNode(id);
  }

  function centerOnNode(id){
    const el = document.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
    if(!el) return;

    // node box in unscaled coords
    const nodeLeft = el.offsetLeft;
    const nodeTop  = el.offsetTop;

    // center coordinates considering scale
    const cx = (nodeLeft + NODE_W/2) * scale;
    const cy = (nodeTop + NODE_H/2) * scale;

    const targetLeft = cx - viewport.clientWidth / 2;
    const targetTop  = cy - viewport.clientHeight / 2;

    viewport.scrollTo({
      left: Math.max(0, targetLeft),
      top:  Math.max(0, targetTop),
      behavior: "smooth"
    });
  }

  function fitToScreen(){
    // Find bounding box of nodes (in unscaled coords)
    const nodes = Array.from(document.querySelectorAll(".node"));
    if(!nodes.length) return;

    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const el of nodes){
      minX = Math.min(minX, el.offsetLeft);
      minY = Math.min(minY, el.offsetTop);
      maxX = Math.max(maxX, el.offsetLeft + NODE_W);
      maxY = Math.max(maxY, el.offsetTop + NODE_H);
    }

    const contentW = (maxX - minX);
    const contentH = (maxY - minY);

    const sx = viewport.clientWidth  / (contentW + 140);
    const sy = viewport.clientHeight / (contentH + 140);
    setScale(Math.min(sx, sy, 1.5));

    // center on bounding box center
    const centerId = selectedId || data.nodes[0]?.id;
    if(centerId) centerOnNode(centerId);
  }

  function resetView(){
    setScale(1);
    viewport.scrollTo({ left: 0, top: 0, behavior: "smooth" });
  }

  // Pan by dragging on empty space
  let isPanning = false;
  let panStart = { x:0, y:0, left:0, top:0 };
  viewport.addEventListener("pointerdown", (e) => {
    // Only pan when clicking background (not node)
    if(e.target.closest(".node")) return;
    isPanning = true;
    viewport.setPointerCapture(e.pointerId);
    panStart = { x:e.clientX, y:e.clientY, left: viewport.scrollLeft, top: viewport.scrollTop };
  });
  viewport.addEventListener("pointermove", (e) => {
    if(!isPanning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    viewport.scrollLeft = panStart.left - dx;
    viewport.scrollTop  = panStart.top  - dy;
  });
  viewport.addEventListener("pointerup", () => { isPanning = false; });

  // Zoom with wheel (keeps cursor position stable-ish)
  viewport.addEventListener("wheel", (e) => {
    // trackpads send small deltas; allow smooth zoom with Ctrl or plain wheel
    const isZoomGesture = e.ctrlKey || Math.abs(e.deltaY) > 0;
    if(!isZoomGesture) return;
    e.preventDefault();

    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left + viewport.scrollLeft;
    const my = e.clientY - rect.top  + viewport.scrollTop;

    const prev = scale;
    const delta = -e.deltaY;
    const factor = Math.exp(delta * 0.0012);
    setScale(prev * factor);

    // Adjust scroll to keep mouse point consistent
    const ratio = scale / prev;
    viewport.scrollLeft = mx * ratio - (e.clientX - rect.left);
    viewport.scrollTop  = my * ratio - (e.clientY - rect.top);
  }, { passive:false });

  // Buttons
  zoomInBtn.addEventListener("click", () => setScale(scale * 1.15));
  zoomOutBtn.addEventListener("click", () => setScale(scale / 1.15));
  resetBtn.addEventListener("click", resetView);
  fitBtn.addEventListener("click", fitToScreen);
  centerBtn.addEventListener("click", () => selectedId && centerOnNode(selectedId));

  // Search
  function doSearch(){
    const q = (searchInput.value || "").trim().toLowerCase();
    if(!q) return;
    const match = data.nodes.find(n =>
      n.name.toLowerCase().includes(q) || n.role.toLowerCase().includes(q) || n.id.toLowerCase() === q
    );
    if(match) selectNode(match.id, true);
  }
  searchBtn.addEventListener("click", doSearch);
  searchInput.addEventListener("keydown", (e) => { if(e.key === "Enter") doSearch(); });

  // Keyboard panning
  viewport.addEventListener("keydown", (e) => {
    const step = 70;
    if(e.key === "ArrowLeft") viewport.scrollLeft -= step;
    if(e.key === "ArrowRight") viewport.scrollLeft += step;
    if(e.key === "ArrowUp") viewport.scrollTop -= step;
    if(e.key === "ArrowDown") viewport.scrollTop += step;
  });

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[s]));
  }

  // Initial render
  render();
  // Start reasonably centered and fitted
  setTimeout(() => fitToScreen(), 0);
</script>
</body>
</html>
